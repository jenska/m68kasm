package asm

import "fmt"

var instrDefsByOpcode = func() map[Opcode]*InstrDef {
	defs := make(map[Opcode]*InstrDef, len(InstrTable))
	for i := range InstrTable {
		d := &InstrTable[i]
		defs[d.Op] = d
	}
	return defs
}()

func getInstrDef(op Opcode) *InstrDef {
	return instrDefsByOpcode[op]
}

type Program struct {
	Items  []any
	Labels map[string]uint32
	Origin uint32
}

// Assemble walks through the parsed program and encodes each instruction or data block.
// It resolves labels using the symbol table generated by the parser.
func Assemble(p *Program) ([]byte, error) {
	out := make([]byte, 0, 1024)

	for _, it := range p.Items {
		switch x := it.(type) {
		case *Instr:
			def := getInstrDef(x.Op)
			if def == nil {
				return nil, fmt.Errorf("no definition for opcode %v", x.Op)
			}
			// For now we assume a single form per instruction.
			form := &def.Forms[0]

			if form.Validate != nil {
				if err := form.Validate(&x.Args); err != nil {
					return nil, err
				}
			}

			bytes, err := Encode(def, form, x, p.Labels)
			if err != nil {
				return nil, fmt.Errorf("line %d: %v", x.Line, err)
			}
			out = append(out, bytes...)

		case *DataBytes:
			out = append(out, x.Bytes...)

		default:
			return nil, fmt.Errorf("unknown item type in program")
		}
	}

	return out, nil
}
