package asm

import (
	"fmt"

	"github.com/jenska/m68kasm/internal/asm/instructions"
)

type Program struct {
	Items  []any
	Labels map[string]uint32
	Origin uint32
}

// Assemble walks through the parsed program and encodes each instruction or data block.
// It resolves labels using the symbol table generated by the parser.
func Assemble(p *Program) ([]byte, error) {
	out := make([]byte, 0, 1024)

	for _, it := range p.Items {
		switch x := it.(type) {
		case *Instr:
			def := x.Def
			if def == nil {
				return nil, fmt.Errorf("no definition for opcode on line %d", x.Line)
			}
			actualKinds := operandKinds(&x.Args)
			form, err := selectForm(def, x, actualKinds)
			if err != nil {
				return nil, fmt.Errorf("line %d: %v", x.Line, err)
			}

			if form.Validate != nil {
				if err := form.Validate(&x.Args); err != nil {
					return nil, fmt.Errorf("line %d: %v", x.Line, err)
				}
			}

			bytes, err := Encode(def, form, x, p.Labels)
			if err != nil {
				return nil, fmt.Errorf("line %d: %v", x.Line, err)
			}
			out = append(out, bytes...)

		case *DataBytes:
			out = append(out, x.Bytes...)

		default:
			return nil, fmt.Errorf("unknown item type in program")
		}
	}

	return out, nil
}

func selectForm(def *instructions.InstrDef, ins *Instr, actual []instructions.OperandKind) (*instructions.FormDef, error) {
	for i := range def.Forms {
		form := &def.Forms[i]
		if len(form.Sizes) > 0 {
			if !sizeAllowed(form.Sizes, ins.Args.Size) {
				continue
			}
		}
		if len(form.OperKinds) > 0 {
			if !operKindsMatch(form.OperKinds, actual) {
				continue
			}
		}
		return form, nil
	}
	return nil, fmt.Errorf("no form matches operands/size for %s", def.Mnemonic)
}

func sizeAllowed(list []instructions.Size, sz instructions.Size) bool {
	for _, v := range list {
		if v == sz {
			return true
		}
	}
	return false
}

func operandKinds(a *instructions.Args) []instructions.OperandKind {
	var kinds [3]instructions.OperandKind
	n := 0
	haveTarget := false
	if a.HasImmQuick {
		kinds[n] = instructions.OPK_ImmQuick
		n++
	} else if a.RegMaskSrc != 0 {
		kinds[n] = instructions.OPK_RegList
		n++
	} else if a.Src.Kind != instructions.EAkNone {
		kinds[n] = operandKindFromEA(a.Src)
		n++
	} else if a.Target != "" {
		kinds[n] = instructions.OPK_DispRel
		n++
		haveTarget = true
	}

	if a.RegMaskDst != 0 {
		kinds[n] = instructions.OPK_RegList
		n++
	} else if a.Dst.Kind != instructions.EAkNone {
		kinds[n] = operandKindFromEA(a.Dst)
		n++
	}

	if a.Target != "" && !haveTarget {
		kinds[n] = instructions.OPK_DispRel
		n++
	}

	return kinds[:n]
}

func operandKindFromEA(e instructions.EAExpr) instructions.OperandKind {
	switch e.Kind {
	case instructions.EAkDn:
		return instructions.OPK_Dn
	case instructions.EAkAn:
		return instructions.OPK_An
	case instructions.EAkAddrPredec:
		return instructions.OPK_PredecAn
	case instructions.EAkImm:
		return instructions.OPK_Imm
	case instructions.EAkNone:
		return instructions.OPK_None
	default:
		return instructions.OPK_EA
	}
}

func operKindsMatch(expected, actual []instructions.OperandKind) bool {
	if len(expected) != len(actual) {
		return false
	}
	for i := range expected {
		if !operandKindCompatible(expected[i], actual[i]) {
			return false
		}
	}
	return true
}

func operandKindCompatible(expect, actual instructions.OperandKind) bool {
	if expect == actual {
		return true
	}
	switch expect {
	case instructions.OPK_EA:
		switch actual {
		case instructions.OPK_EA, instructions.OPK_Dn, instructions.OPK_An, instructions.OPK_Imm, instructions.OPK_PredecAn:
			return true
		}
	}
	return false
}
