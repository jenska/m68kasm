package asm

import (
	"fmt"
	"io"

	"github.com/jenska/m68kasm/internal/asm/instructions"
)

type Program struct {
	Items  []any
	Labels map[string]uint32
	Origin uint32
}

// ListingEntry captures the assembled bytes for a single source line so that a
// human-readable listing file can be generated.
type ListingEntry struct {
	Line  int
	PC    uint32
	Bytes []byte
}

// Assemble walks through the parsed program and encodes each instruction or data block.
// It resolves labels using the symbol table generated by the parser.
func Assemble(p *Program) ([]byte, error) {
	out, _, _, err := assemble(nil, nil, p, false)
	return out, err
}

// AssembleInto appends the assembled program bytes into dst and returns the resulting slice.
func AssembleInto(dst []byte, p *Program) ([]byte, error) {
	out, _, _, err := assemble(dst, nil, p, false)
	return out, err
}

// AssembleWithListing assembles the program and also returns a per-line listing
// describing the generated bytes at each program counter.
func AssembleWithListing(p *Program) ([]byte, []ListingEntry, error) {
	return AssembleWithListingInto(nil, p)
}

// AssembleWithListingInto appends the assembled program bytes into dst and
// returns both the resulting slice and listing metadata.
func AssembleWithListingInto(dst []byte, p *Program) ([]byte, []ListingEntry, error) {
	out, listing, _, err := assemble(dst, nil, p, true)
	return out, listing, err
}

// AssembleStream writes the assembled program bytes directly into w. The total
// number of bytes written is returned so that callers can pre-size buffers.
func AssembleStream(w io.Writer, p *Program) (int64, error) {
	_, _, written, err := assemble(nil, w, p, false)
	return written, err
}

// AssembleStreamWithListing writes the assembled program bytes directly into w
// while also returning a per-line listing of the emitted data.
func AssembleStreamWithListing(w io.Writer, p *Program) (int64, []ListingEntry, error) {
	out, listing, written, err := assemble(nil, w, p, true)
	_ = out
	return written, listing, err
}

func assemble(dst []byte, w io.Writer, p *Program, wantListing bool) ([]byte, []ListingEntry, int64, error) {
	out := dst
	if out == nil && w == nil {
		out = make([]byte, 0, 1024)
	}

	var listing []ListingEntry
	if wantListing {
		listing = make([]ListingEntry, 0, len(p.Items))
	}

	var written int64
	itemBuf := make([]byte, 0, 32)

	for _, it := range p.Items {
		itemBuf = itemBuf[:0]
		switch x := it.(type) {
		case *Instr:
			ins := *x
			ins.Args = x.Args

			def := x.Def
			if def == nil {
				return nil, nil, written, errorAtLine(x.Line, fmt.Errorf("no definition for opcode"))
			}
			actualKinds := operandKinds(&ins.Args)
			form, err := selectForm(def, &ins, actualKinds)
			if err != nil {
				return nil, nil, written, contextualize(x.Line, err)
			}

			if form.Validate != nil {
				if err := form.Validate(&ins.Args); err != nil {
					return nil, nil, written, contextualize(x.Line, err)
				}
			}

			bytes, err := Encode(def, form, &ins, p.Labels)
			if err != nil {
				return nil, nil, written, contextualize(x.Line, err)
			}
			itemBuf = append(itemBuf, bytes...)

		case *DataBytes:
			itemBuf = append(itemBuf, x.Bytes...)

		default:
			return nil, nil, written, fmt.Errorf("unknown item type in program")
		}

		if w != nil {
			n, err := w.Write(itemBuf)
			if err != nil {
				return out, listing, written, err
			}
			written += int64(n)
		} else {
			out = append(out, itemBuf...)
		}

		if wantListing {
			entry := ListingEntry{PC: pcForItem(it), Line: lineForItem(it)}
			entry.Bytes = append(entry.Bytes, itemBuf...)
			listing = append(listing, entry)
		}
	}

	return out, listing, written, nil
}

func selectForm(def *instructions.InstrDef, ins *Instr, actual []instructions.OperandKind) (*instructions.FormDef, error) {
	for i := range def.Forms {
		form := &def.Forms[i]
		if len(form.Sizes) > 0 {
			if !sizeAllowed(form.Sizes, ins.Args.Size) {
				continue
			}
		}
		if len(form.OperKinds) > 0 {
			if !operKindsMatch(form.OperKinds, actual) {
				continue
			}
		}
		return form, nil
	}
	return nil, fmt.Errorf("no form matches operands/size for %s", def.Mnemonic)
}

func sizeAllowed(list []instructions.Size, sz instructions.Size) bool {
	for _, v := range list {
		if v == sz {
			return true
		}
	}
	return false
}

func operandKinds(a *instructions.Args) []instructions.OperandKind {
	var kinds [3]instructions.OperandKind
	n := 0
	haveTarget := false
	if a.HasImmQuick {
		kinds[n] = instructions.OpkImmQuick
		n++
	} else if a.RegMaskSrc != 0 {
		kinds[n] = instructions.OpkRegList
		n++
	} else if a.Src.Kind != instructions.EAkNone {
		kinds[n] = operandKindFromEA(a.Src)
		n++
	} else if a.Target != "" {
		kinds[n] = instructions.OpkDispRel
		n++
		haveTarget = true
	}

	if a.RegMaskDst != 0 {
		kinds[n] = instructions.OpkRegList
		n++
	} else if a.Dst.Kind != instructions.EAkNone {
		kinds[n] = operandKindFromEA(a.Dst)
		n++
	}

	if a.Target != "" && !haveTarget {
		kinds[n] = instructions.OpkDispRel
		n++
	}

	return kinds[:n]
}

var operandKindByEA = map[instructions.EAExprKind]instructions.OperandKind{
	instructions.EAkNone:       instructions.OpkNone,
	instructions.EAkImm:        instructions.OpkImm,
	instructions.EAkDn:         instructions.OpkDn,
	instructions.EAkAn:         instructions.OpkAn,
	instructions.EAkAddrPredec: instructions.OpkPredecAn,
	instructions.EAkSR:         instructions.OpkSR,
	instructions.EAkCCR:        instructions.OpkCCR,
	instructions.EAkUSP:        instructions.OpkUSP,
}

// operandKindFromEA classifies an EA expression into the broader operand kind categories
// used by instruction form matching, defaulting to OpkEA for generic addressing modes.
func operandKindFromEA(e instructions.EAExpr) instructions.OperandKind {
	if kind, ok := operandKindByEA[e.Kind]; ok {
		return kind
	}
	return instructions.OpkEA
}

func operKindsMatch(expected, actual []instructions.OperandKind) bool {
	if len(expected) != len(actual) {
		return false
	}
	for i := range expected {
		if !operandKindCompatible(expected[i], actual[i]) {
			return false
		}
	}
	return true
}

func operandKindCompatible(expect, actual instructions.OperandKind) bool {
	if expect == actual {
		return true
	}
	switch expect {
	case instructions.OpkEA:
		switch actual {
		case instructions.OpkEA, instructions.OpkDn, instructions.OpkAn, instructions.OpkImm, instructions.OpkPredecAn:
			return true
		}
	}
	return false
}

func pcForItem(it any) uint32 {
	switch v := it.(type) {
	case *Instr:
		return v.PC
	case *DataBytes:
		return v.PC
	default:
		return 0
	}
}

func lineForItem(it any) int {
	switch v := it.(type) {
	case *Instr:
		return v.Line
	case *DataBytes:
		return v.Line
	default:
		return 0
	}
}
