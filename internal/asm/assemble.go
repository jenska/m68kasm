package asm

import (
	"fmt"

	"github.com/jenska/m68kasm/internal/asm/instructions"
)

type Program struct {
	Items  []any
	Labels map[string]uint32
	Origin uint32
}

// ListingEntry captures the assembled bytes for a single source line so that a
// human-readable listing file can be generated.
type ListingEntry struct {
	Line  int
	PC    uint32
	Bytes []byte
}

// Assemble walks through the parsed program and encodes each instruction or data block.
// It resolves labels using the symbol table generated by the parser.
func Assemble(p *Program) ([]byte, error) {
	out, _, err := assemble(nil, p, false)
	return out, err
}

// AssembleInto appends the assembled program bytes into dst and returns the resulting slice.
func AssembleInto(dst []byte, p *Program) ([]byte, error) {
	out, _, err := assemble(dst, p, false)
	return out, err
}

// AssembleWithListing assembles the program and also returns a per-line listing
// describing the generated bytes at each program counter.
func AssembleWithListing(p *Program) ([]byte, []ListingEntry, error) {
	return AssembleWithListingInto(nil, p)
}

// AssembleWithListingInto appends the assembled program bytes into dst and
// returns both the resulting slice and listing metadata.
func AssembleWithListingInto(dst []byte, p *Program) ([]byte, []ListingEntry, error) {
	return assemble(dst, p, true)
}

func assemble(dst []byte, p *Program, wantListing bool) ([]byte, []ListingEntry, error) {
	out := dst
	if out == nil {
		out = make([]byte, 0, 1024)
	}

	var listing []ListingEntry
	if wantListing {
		listing = make([]ListingEntry, 0, len(p.Items))
	}

	for _, it := range p.Items {
		start := len(out)
		switch x := it.(type) {
		case *Instr:
			def := x.Def
			if def == nil {
				return nil, nil, fmt.Errorf("no definition for opcode on line %d", x.Line)
			}
			actualKinds := operandKinds(&x.Args)
			form, err := selectForm(def, x, actualKinds)
			if err != nil {
				return nil, nil, fmt.Errorf("line %d: %v", x.Line, err)
			}

			if form.Validate != nil {
				if err := form.Validate(&x.Args); err != nil {
					return nil, nil, fmt.Errorf("line %d: %v", x.Line, err)
				}
			}

			bytes, err := Encode(def, form, x, p.Labels)
			if err != nil {
				return nil, nil, fmt.Errorf("line %d: %v", x.Line, err)
			}
			out = append(out, bytes...)

		case *DataBytes:
			out = append(out, x.Bytes...)

		default:
			return nil, nil, fmt.Errorf("unknown item type in program")
		}

		if wantListing {
			entry := ListingEntry{PC: pcForItem(it), Line: lineForItem(it)}
			entry.Bytes = append(entry.Bytes, out[start:]...)
			listing = append(listing, entry)
		}
	}

	return out, listing, nil
}

func selectForm(def *instructions.InstrDef, ins *Instr, actual []instructions.OperandKind) (*instructions.FormDef, error) {
	for i := range def.Forms {
		form := &def.Forms[i]
		if len(form.Sizes) > 0 {
			if !sizeAllowed(form.Sizes, ins.Args.Size) {
				continue
			}
		}
		if len(form.OperKinds) > 0 {
			if !operKindsMatch(form.OperKinds, actual) {
				continue
			}
		}
		return form, nil
	}
	return nil, fmt.Errorf("no form matches operands/size for %s", def.Mnemonic)
}

func sizeAllowed(list []instructions.Size, sz instructions.Size) bool {
	for _, v := range list {
		if v == sz {
			return true
		}
	}
	return false
}

func operandKinds(a *instructions.Args) []instructions.OperandKind {
	var kinds [3]instructions.OperandKind
	n := 0
	haveTarget := false
	if a.HasImmQuick {
		kinds[n] = instructions.OPK_ImmQuick
		n++
	} else if a.RegMaskSrc != 0 {
		kinds[n] = instructions.OPK_RegList
		n++
	} else if a.Src.Kind != instructions.EAkNone {
		kinds[n] = operandKindFromEA(a.Src)
		n++
	} else if a.Target != "" {
		kinds[n] = instructions.OPK_DispRel
		n++
		haveTarget = true
	}

	if a.RegMaskDst != 0 {
		kinds[n] = instructions.OPK_RegList
		n++
	} else if a.Dst.Kind != instructions.EAkNone {
		kinds[n] = operandKindFromEA(a.Dst)
		n++
	}

	if a.Target != "" && !haveTarget {
		kinds[n] = instructions.OPK_DispRel
		n++
	}

	return kinds[:n]
}

var operandKindByEA = map[instructions.EAExprKind]instructions.OperandKind{
	instructions.EAkNone:       instructions.OPK_None,
	instructions.EAkImm:        instructions.OPK_Imm,
	instructions.EAkDn:         instructions.OPK_Dn,
	instructions.EAkAn:         instructions.OPK_An,
	instructions.EAkAddrPredec: instructions.OPK_PredecAn,
	instructions.EAkSR:         instructions.OPK_SR,
	instructions.EAkCCR:        instructions.OPK_CCR,
	instructions.EAkUSP:        instructions.OPK_USP,
}

// operandKindFromEA classifies an EA expression into the broader operand kind categories
// used by instruction form matching, defaulting to OPK_EA for generic addressing modes.
func operandKindFromEA(e instructions.EAExpr) instructions.OperandKind {
	if kind, ok := operandKindByEA[e.Kind]; ok {
		return kind
	}
	return instructions.OPK_EA
}

func operKindsMatch(expected, actual []instructions.OperandKind) bool {
	if len(expected) != len(actual) {
		return false
	}
	for i := range expected {
		if !operandKindCompatible(expected[i], actual[i]) {
			return false
		}
	}
	return true
}

func operandKindCompatible(expect, actual instructions.OperandKind) bool {
	if expect == actual {
		return true
	}
	switch expect {
	case instructions.OPK_EA:
		switch actual {
		case instructions.OPK_EA, instructions.OPK_Dn, instructions.OPK_An, instructions.OPK_Imm, instructions.OPK_PredecAn:
			return true
		}
	}
	return false
}

func pcForItem(it any) uint32 {
	switch v := it.(type) {
	case *Instr:
		return v.PC
	case *DataBytes:
		return v.PC
	default:
		return 0
	}
}

func lineForItem(it any) int {
	switch v := it.(type) {
	case *Instr:
		return v.Line
	case *DataBytes:
		return v.Line
	default:
		return 0
	}
}
