package asm

import "fmt"

// Assemble walks through the parsed program and encodes each instruction or data block.
// It resolves labels using the symbol table generated by the parser.
func Assemble(p *Program) ([]byte, error) {
	out := make([]byte, 0, 1024)

	// Build a quick lookup table for instruction definitions
	defs := map[Opcode]*InstrDef{}
	for i := range InstrTable {
		d := &InstrTable[i]
		defs[d.Op] = d
	}

	for _, it := range p.Items {
		switch x := it.(type) {
		case *Instr:
			def := defs[x.Op]
			if def == nil {
				return nil, fmt.Errorf("no definition for opcode %v", x.Op)
			}
			// For now we assume a single form per instruction.
			form := &def.Forms[0]

			if form.Validate != nil {
				if err := form.Validate(&x.Args); err != nil {
					return nil, err
				}
			}

			bytes, err := Encode(def, form, x, p.Labels)
			if err != nil {
				return nil, fmt.Errorf("line %d: %v", x.Line, err)
			}
			out = append(out, bytes...)

		case *DataBytes:
			out = append(out, x.Bytes...)

		default:
			return nil, fmt.Errorf("unknown item type in program")
		}
	}

	return out, nil
}
